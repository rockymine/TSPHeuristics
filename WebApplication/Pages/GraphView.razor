@page "/graph"
@using Excubo.Blazor.Canvas
@using Excubo.Blazor.Canvas.Contexts
@using TravellingSalesmanProblem.Algorithms
@using TravellingSalesmanProblem.Graph
@using WebApplication.Utils
<div class="container-fluid">
    <div class="col">
        <h2 class="font-weight-bold">Web Application for the interactive visualization of different heuristics</h2>
        <h4 class="font-weight-light">Master thesis project of Michael Ganske at the University of Hildesheim</h4>
        <div class="row">
            <div class="col-md-4 col-sm-6">
                <h3 class="font-weight-bold">Settings</h3>
                <div class="row">
                    <div class="col-md-6 col-sm-6">
                        <h5 class="font-weight-light">Select Heuristics</h5>
                        <div class="form-group">
                            <select class="form-control" name="heuristics" id="selectHeuristics" @bind="algorithmEnum">
                                <option value="NN" @onselect="e => algorithmEnum = AlgorithmEnum.NN">Nearest Neighbor</option>
                                <option value="SA" @onselect="e => algorithmEnum = AlgorithmEnum.SA">Simulated Annealing</option>
                                <option value="MSNN" @onselect="e => algorithmEnum = AlgorithmEnum.MSNN">Multi Start (NN)</option>
                                <option value="ACS" @onselect="e => algorithmEnum = AlgorithmEnum.ACS">Ant Colony System</option>
                            </select>
                        </div>
                    </div>
                    <div class="col-md-6 col-sm-6">
                        @if (enumerator != null && algorithmEnum == AlgorithmEnum.NN) {
                            <h5 class="font-weight-light">Algorithm specific settings</h5>
                            <div class="form-group">
                                <label for="startnodeselect">Select Start Node</label>
                                <div id="startnodeselect" class="input-group">
                                    <div class="input-group-prepend">
                                        <button class="btn btn-primary btn-sm" type="button" @onclick="e => StartNode--">-</button>
                                    </div>
                                    <div class="input-group-text">@StartNode</div>
                                    <div class="input-group-append">
                                        <button class="btn btn-primary btn-sm" type="button" @onclick="e => StartNode++">+</button>
                                    </div>
                                </div>
                            </div>
                        }
                    </div>
                </div>
                <hr/>
                <h5 class="font-font-weight-light">Parameters for text-based graph</h5>
                <div class="form-group">
                    <textarea class="form-control" @bind="graphDefinition" style="height: 200px;"></textarea>
                </div>
                <div class="form-group">
                    <button class="btn btn-primary" type="button" @onclick="e => InitiateGraph(true)">Draw From Text</button>
                </div>
                <hr/>
                <h5 class="font-font-weight-light">Parameters for random graph</h5>
                <div class="row">
                    <div class="col">
                        <div class="form-group">
                            <label for="maxWidth">Max. Width</label>
                            <input type="number" id="maxWidth" class="form-control" @bind="MaxX">
                        </div>
                    </div>
                    <div class="col">
                        <div class="form-group">
                            <label for="maxHeight">Max. Height</label>
                            <input type="number" id="maxHeight" class="form-control" @bind="MaxY">
                        </div>
                    </div>
                    <div class="col">
                        <div class="form-group">
                            <label for="maxNodes">Nodes</label>
                            <input type="number" id="maxNodes" class="form-control" @bind="NodeCount">
                        </div>
                    </div>
                </div>
                <div class="form-group">
                    <button class="btn btn-primary" type="button" @onclick="e => InitiateGraph(false)">Draw Random Graph</button>
                </div>
            </div>
            <div class="col-md-8 col-sm-6">
                <h3 class="font-weight-bold">Graphs</h3>
                <div class="row">
                    <div class="col">
                        <h5 class="font-weight-bold">Current</h5>
                        <Canvas @ref="currentCanvas" width="@CanvasWidth" height="@CanvasHeight"></Canvas>
                        @if (enumerator != null && !enumerator.Current.Finished) {
                            @if (!autoAdvance) {
                                <div class="form-group">
                                    <button class="btn btn-primary btn-sm" type="button" @onclick="e => NextState(false)">Advance to next Graph State</button>
                                </div>
                            }
                            <div class="form-group">
                                <div class="custom-control custom-switch">
                                    <input class="custom-control-input" type="checkbox" id="switch" @bind="autoAdvance">
                                    <label class="custom-control-label" for="switch">Toggle auto-advance</label>
                                </div>
                            </div>
                        }
                        @if (previous != null ) {
                            <div class="form-group">
                                <button class="btn btn-danger btn-sm" type="button" @onclick="e => NextState(true)">Reset</button>
                            </div>
                        }
                        <hr/>
                        @if (enumerator != null && enumerator.Current != null) {
                            <h5 class="font-weight-light">State Messages</h5>
                            <span><b>Success</b>: @enumerator.Current.Success</span><br/>
                            <span><b>Finished</b>: @enumerator.Current.Finished</span><br/>

                            @foreach (var kvp in enumerator.Current.Messages) {
                                <span><b>@kvp.Key</b>: @kvp.Value</span><br/>
                            }
                        }
                    </div>
                    <div class="col">
                        <h5 class="font-weight-bold">Previous</h5>
                        <Canvas @ref="previousCanvas" width="@CanvasWidth" height="@CanvasHeight"></Canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

@*@if (algorithmEnum == AlgorithmEnum.NN) {
    <TableGenerator @ref="tableGenerator"/>
}
@if (algorithmEnum == AlgorithmEnum.SA) {
    <ChartGenerator @ref="chartGenerator"/>
}*@

@code {
    //components
	private Canvas currentCanvas;
    private Canvas previousCanvas;
	private TableGenerator tableGenerator;
    private ChartGenerator chartGenerator;

	//graph
	private GraphProblem graph;
    private GraphState previous;
    private NearestNeighbour nearestNeighbour = new();
    private SimulatedAnnealing simulatedAnnealing = new();
    private AntAlgorithm antColonySystem = new();
	private IEnumerator<GraphState> enumerator;
	private AlgorithmEnum algorithmEnum;
	private string graphDefinition = @"n,1,11,5
n,2,6,4
n,3,4,10
n,4,4,2
n,5,2,4
n,6,7,7
n,7,8,8
n,8,9,2
n,9,5,7
n,10,7,1
n,11,1,6
n,12,11,11";

    private const float Scale = 20;
    private const int Delay = 50;

    private int CanvasWidth;
    private int CanvasHeight;
    private int NodeMax;
    private bool autoAdvance;
    private bool drawComplete;

    private int _nodeValue;
    private int _horizontal = 30;
    private int _vertical = 30;
    private int _count = 30;

    private int StartNode {
        get => _nodeValue;
        set {
            if (value == _nodeValue)
                return;
            if (value < 0 || value > NodeMax)
                return;

            _nodeValue = value;
            UpdateGraph();
        }
    }

    private int MaxX {
        get => _horizontal;
        set {
            if (value == _horizontal)
                return;
            if (value < 10 || value > 90)
                return;

            _horizontal = value;
        }
    }
    
    private int MaxY {
        get => _vertical;
        set {
            if (value == _vertical)
                return;
            if (value < 10 || value > 90)
                return;

            _vertical = value;
        }
    }
    
    private int NodeCount {
        get => _count;
        set {
            if (value == _count)
                return;
            if (value < 5 || value > 90)
                return;

            _count = value;
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            //await InitiateGraph(true);
            //await NextState(true);

            Task.Run(async () => {
                while (true) {
                    await Task.Delay(Delay);

                    if (autoAdvance)
                        await NextState(false);
                }
            });
        }
    }

    private async Task InitiateGraph(bool textbased) {
        graph = textbased ? GraphProblem.FromText(graphDefinition) :
        GraphProblem.RandomGraphProblem(MaxX, MaxY, NodeCount);

        await UpdateGraph();
    }

    private async Task UpdateGraph() {
        if (algorithmEnum == AlgorithmEnum.NN)
            NodeMax = graph.Nodes.Count - 1;

        var max = graph.FindMax();
        CanvasWidth = (int)(max.X * Scale) + 50;
        CanvasHeight = (int)(max.Y * Scale) + 50;

        await NextState(true);
    }    

    private async Task NextState(bool reset) {
        if (reset)
            await UpdateEnumerator();
        if (enumerator == null)
            await InitiateGraph(true);

        if (!drawComplete) {
            if (enumerator.Current != null)
                previous = enumerator.Current.DeepCopy();

            enumerator.MoveNext();

            if (previous != null) {
                previous.ComparePathEdges(enumerator.Current);
                await FillCanvas(previousCanvas);
            }

            if (enumerator.Current.Finished)
                drawComplete = true;
            
            await FillCanvas(currentCanvas);
            @*UpdateVisualsFromGraphState();*@
            StateHasChanged();
        }
    }

    private async Task FillCanvas(Canvas canvas) {
        await using (var context = await canvas.GetContext2DAsync()) {
            await ClearAndDrawGrid(context);

            if (canvas == previousCanvas) {
                await DrawPath(context, previous);
            } else {
                await DrawPath(context, enumerator.Current);
            }            
        }
    }

    private async Task DrawPath(Context2D context, GraphState graph) {
        if (graph != null) {
            await CanvasRenderer.DrawEdges(context, graph, CanvasHeight);
            await CanvasRenderer.DrawNodes(context, graph, CanvasHeight);
        }
    }

    private async Task ClearAll() {
        if (previousCanvas != null) {
            previous = null;
            await using (var context = await previousCanvas.GetContext2DAsync()) {
                await ClearAndDrawGrid(context);
            }
        }

        if (currentCanvas != null) {
            await using (var context = await currentCanvas.GetContext2DAsync()) {
                await ClearAndDrawGrid(context);
            }
        }
    }

    private async Task ClearAndDrawGrid(Context2D context) {
        await context.ClearRectAsync(0, 0, CanvasWidth, CanvasHeight);
        await CanvasRenderer.DrawGrid(context, MaxX, MaxY, CanvasHeight);
    }

    private async Task UpdateEnumerator() {
        drawComplete = false;
        await ClearAll();

        switch (algorithmEnum) {
            case AlgorithmEnum.NN:
                nearestNeighbour.Start = graph.Nodes[StartNode];
                enumerator = nearestNeighbour.FindPath(graph).GetEnumerator();
                break;
            case AlgorithmEnum.SA:
                enumerator = simulatedAnnealing.FindPath(graph).GetEnumerator();
                break;
            case AlgorithmEnum.MSNN:
                enumerator = nearestNeighbour.MultiStart(graph).GetEnumerator();
                break;
            case AlgorithmEnum.ACS:
                enumerator = antColonySystem.FindPath(graph).GetEnumerator();
                break;
            default: break;
        }
    }

    @*private void UpdateVisualsFromGraphState() {
        if (algorithmEnum == AlgorithmEnum.NN)
            tableGenerator.UpdateFromGraphState(enumerator.Current);
        if (algorithmEnum == AlgorithmEnum.SA)
            chartGenerator.UpdateFromGraphState(enumerator.Current);
    }*@
}