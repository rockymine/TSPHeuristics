@page "/graph"
@using Excubo.Blazor.Canvas
@using Excubo.Blazor.Canvas.Contexts
@using System.Diagnostics
@using TravellingSalesmanProblem.Algorithms
@using TravellingSalesmanProblem.Graph
@using WebApplication.Utils
@using WebApplication.Components
@using StardustDL.RazorComponents.Markdown
<div class="container-fluid">
    <h2 class="font-weight-bold">Interactive visualization of different TSP heuristics</h2>
    <div class="row">
        <div class="col-md-3 p-0"><!-- Settings -->
            <div class="bg-custom-light custom-input-group">
                <AlgorithmSettings @bind-algorithmEnum="@algorithmEnum" @bind-MultiStart="@multiStart"
                    @bind-ShowPrevious="@showPrevious"></AlgorithmSettings>
            </div>
        </div>
        <div class="col-md-9 p-0">
            <div class="bg-custom-light custom-input-group">
                <h5>Heuristic Settings</h5>
                @if (enumerator != null) {
                    @if (algorithmEnum == AlgorithmEnum.NN && !multiStart) {
                        <NearestNeighborSettings @bind-StartNode="@StartNode"></NearestNeighborSettings>
                    }
                    @if (algorithmEnum == AlgorithmEnum.SA) {
                        <SimulatedAnnealingSettings @bind-AlphaSA="@AlphaSA" @bind-MaxIter1="@MaxIter1" @bind-MaxIter2="@MaxIter2"
                            @bind-MinTemp="@MinTemp" @bind-StartTemp="@StartTemp"></SimulatedAnnealingSettings>
                    }
                    @if (algorithmEnum == AlgorithmEnum.HC) {
                        <SimulatedAnnealingSettings @bind-NeighbourEnum="neighbourEnum"></SimulatedAnnealingSettings>
                    }
                    @if (algorithmEnum == AlgorithmEnum.ACS) {
                        <AntColonySettings @bind-AlphaACS="AlphaACS" @bind-AntCount="AntCount" @bind-Beta="Beta"
                            @bind-Rho="Rho" @bind-ExploitVsExplore="ExploitVsExplore"></AntColonySettings>
                    }
                    <div class="form-group">
                        <button class="btn btn-danger" type="button" @onclick="e => NextState(true)">Reset</button>
                    </div>
                }
            </div>
        </div>
    </div>
    <div class="row">
        <p>
            <button class="btn btn-primary" @onclick="@(e => graphSettingsCollapse = graphSettingsCollapse == "" ? "collapse" : "")">
                Graph settings ˅
            </button>
        </p>
        <div class="@graphSettingsCollapse" id="collapseExample">
            <div class="row">
                <div class="col-md-6 p-0">
                    <div class="bg-custom-light custom-input-group">
                        <h5>Text-based graph</h5>
                        <div class="form-group">
                            <textarea class="form-control" @bind="graphDefinition" style="height: 200px;"></textarea>
                        </div>
                        <div class="form-group">
                            <button class="btn btn-primary" type="button" @onclick="e => InitiateGraph(true)">Draw From Text</button>
                        </div>
                    </div>
                </div>
                <div class="col-md-6 p-0">
                    <div class="bg-custom-light custom-input-group">
                        <RandomGraphSettings @bind-NodeCount="NodeCount" @bind-MaxX="MaxX" @bind-MaxY="MaxY"></RandomGraphSettings>
                        <div class="form-group">
                            <button class="btn btn-primary" type="button" @onclick="e => InitiateGraph(false)">Draw Random Graph</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-md-8 p-0">
            <div class="bg-custom-light custom-input-group">
                <h5>Graph View</h5>
                <div class="row">
                    <div class="col">
                        <h5 class="font-weight-bold">Current</h5>
                        <Canvas @ref="currentCanvas" width="@CanvasWidth" height="@CanvasHeight"></Canvas>
                    </div>
                    <div class="col">
                        @if (showPrevious && (algorithmEnum == AlgorithmEnum.SA || algorithmEnum == AlgorithmEnum.HC)) {
                            <h5 class="font-weight-bold">Previous</h5>
                            <Canvas @ref="previousCanvas" width="@CanvasWidth" height="@CanvasHeight"></Canvas>
                        }
                    </div>
                </div>
            </div>
        </div>
        <div class="col-md-4 p-0">
            <div class="bg-custom-light custom-input-group">
                <h5>State</h5>
                @if (enumerator != null && !enumerator.Current.Finished) {
                    <div class="row g-3">
                        <div class="input-group">
                            <div class="col-auto">
                                @if (!autoAdvance) {
                                    <div class="form-group">
                                        <button class="btn btn-primary btn-sm" type="button" @onclick="e => NextState(false)">Next</button>
                                    </div>
                                }
                            </div>
                            <div class="col-auto">
                                <div class="form-check">
                                    <input class="form-check-input" type="checkbox" id="switch" @bind="autoAdvance">
                                    <label class="form-check-label" for="switch">Auto</label>
                                </div>
                            </div>
                        </div>
                    </div>
                }
                @if (enumerator != null && enumerator.Current != null) {
                    <span><b>Success</b>: @enumerator.Current.Success</span><br/>
                    <span><b>Finished</b>: @enumerator.Current.Finished</span><br/>
                    <span><b>Elapsed Time</b>: @TimeSpan.Minutes m @TimeSpan.Seconds s @TimeSpan.Milliseconds ms</span><br/>

                    @foreach (var kvp in enumerator.Current.Messages) {
                        <span><b>@kvp.Key</b>: @kvp.Value</span><br/>
                    }
                }
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-md-12">
            <h5>Details</h5>
            @if (enumerator != null && enumerator.Current != null && enumerator.Current.Equations.Count != 0) {
                <div class="row">
                <div class="col-md-6 col-sm-6">
                    <h3 class="font-weight-bold">Formulas</h3>
                        @foreach (var kvp in enumerator.Current.Equations) {
                            <p><b>@kvp.Key</b></p>
                            <MarkdownRenderer Value="@kvp.Value.Latex"/>
                            @*if (kvp.Value.Description != null) {
                                <MarkdownRenderer Value="@kvp.Value.Description"/>
                            }*@
                            <MarkdownRenderer Value="@kvp.Value.Generate()"/>
                            <MarkdownRenderer Value="@kvp.Value.Result"/>
                        }
                    </div>
                </div> 
            }
            @if (algorithmEnum == AlgorithmEnum.SA && enumerator != null && enumerator.Current != null
            && enumerator.Current.Segments != null && enumerator.Current.Segments.Count != 0) {
                <div class="row">
                    @if (additionalCanvases != null && additionalCanvases.Length != 0) {
                        <div class="col">
                            <h5 class="font-weight-bold">Details</h5>
                            <div class="row">
                                @for (int i = 0; i < enumerator.Current.Segments.Count; i++) {
                                    int j = i;
                                    <div class="col">
                                        <div class="card">
                                            <Canvas @ref="additionalCanvases[j]" width="@CanvasWidth" height="@CanvasHeight"></Canvas>
                                            <div class="card-body">
                                                <h5>@enumerator.Current.Segments[j].Identifier</h5>
                                                <h6 class="card-subtitle mb-2 text-muted">@enumerator.Current.Segments[j].Type</h6>
                                                @foreach (var info in enumerator.Current.Segments[j].Info) {
                                                    <span><b>@info.Key</b>: @info.Value</span><br/>
                                                }
                                            </div>
                                        </div>
                                    </div>
                                }
                            </div>
                        </div>
                    }
                </div>
            }
        </div>
    </div>
</div>

@*@if (algorithmEnum == AlgorithmEnum.NN) {
    <TableGenerator @ref="tableGenerator"/>
}
@if (algorithmEnum == AlgorithmEnum.SA) {
    <ChartGenerator @ref="chartGenerator"/>
}*@

@code {
    //components
	private Canvas currentCanvas;
    private Canvas previousCanvas;
    private Canvas[] additionalCanvases = new Canvas[5];
	private TableGenerator tableGenerator;
    private ChartGenerator chartGenerator;

	//graph
	private GraphProblem graph;
    private GraphState previous;
    private NearestNeighbour nearestNeighbour = new();
    private SimulatedAnnealing simulatedAnnealing = new();
    private AntAlgorithm antColonySystem = new();
    private HillClimbing hillClimbing = new();
	private IEnumerator<GraphState> enumerator;
	private AlgorithmEnum algorithmEnum;
    private NeighbourType neighbourEnum;
	private string graphDefinition = @"n,1,11,5
n,2,6,4
n,3,4,10
n,4,4,2
n,5,2,4
n,6,7,7
n,7,8,8
n,8,9,2
n,9,5,7
n,10,7,1
n,11,1,6
n,12,11,11";

    private const float Scale = 20;
    private const int Delay = 1;
    private bool autoAdvance;
    private bool drawComplete;
    private bool showPrevious = true;
    private bool multiStart;
    private string graphSettingsCollapse = "collapse";
    
    /* GraphView Parameters */
    private int CanvasWidth;
    private int CanvasHeight;


    private int _horizontal = 30;
    private int _vertical = 30;
    private int _count = 30;

    private int MaxX {
        get => _horizontal;
        set {
            if (value == _horizontal)
                return;
            if (value < 10 || value > 90)
                return;

            _horizontal = value;
        }
    }
    
    private int MaxY {
        get => _vertical;
        set {
            if (value == _vertical)
                return;
            if (value < 10 || value > 90)
                return;

            _vertical = value;
        }
    }
    
    private int NodeCount {
        get => _count;
        set {
            if (value == _count)
                return;
            if (value < 5 || value > 90)
                return;

            _count = value;
        }
    }

    /* Nearest Neighbor Parameters */
    private int _nodeValue;

    private int StartNode {
        get => _nodeValue;
        set {
            if (value == _nodeValue)
                return;
            if (value < 0 || value > graph.Nodes.Count - 1)
                return;

            _nodeValue = value;
        }
    }

    /* Simulated Annealing Parameters */
    private int _maxIter1 = 20; //iterations without temperature change
    private int _maxIter2 = 400; //temperature changes
    private double _startTemp = 100;
    private double _minTemp = Math.Pow(10,-8);
    private double _alphaSA = 0.98;

    private int MaxIter1 {
        get => _maxIter1;
        set {
            if (value == _maxIter1)
                return;
            if (value < 5 || value > 20)
                return;

            _maxIter1 = value;
        }
    }

    private int MaxIter2 {
        get => _maxIter2;
        set {
            if (value == _maxIter2)
                return;
            if (value < 100 || value > 1000)
                return;

            _maxIter2 = value;
        }
    }

    private double StartTemp {
        get => _startTemp;
        set {
            if (value == _startTemp)
                return;
            if (value < 50 || value > 100_000) {
                return;
            }

            _startTemp = value;
        }
    }

    private double MinTemp {
        get => _minTemp;
        set {
            if (value == _minTemp)
                return;
            if (value < 0.0000001 || value >= _startTemp)
                return;

            _minTemp = value;
        }
    }

    private double AlphaSA {
        get => _alphaSA;
        set {
            if (value == _alphaSA)
                return;
            if (value < 0.5 || value >= 1)
                return;

            _alphaSA = value;
        }
    }

    /* Ant Colony Search Parameters */
    private double _alphaACS = 0.1;
    private double _beta = 2;
    private double _rho = 0.1;
    private double _exploitVsExplore = 0.9;
    private int _antCount = 10;

    private double AlphaACS {
        get => _alphaACS;
        set {
            if (value == _alphaACS)
                return;
            if (value <= 0 || value >= 1)
                return;

            _alphaACS = value;
        }
    }

    private double Beta {
        get => _beta;
        set {
            if (value == _beta)
                return;
            if (value <= 0 || value >= 10)
                return;

            _beta = value;
        }
    }

    private double Rho {
        get => _rho;
        set {
            if (value == _rho)
                return;
            if (value <= 0 || value >= 1)
                return;

            _rho = value;
        }
    }

    private double ExploitVsExplore {
        get => _exploitVsExplore;
        set {
            if (value == _exploitVsExplore)
                return;
            if (value < 0.5 || value >= 1)
                return;

            _exploitVsExplore = value;
        }
    }

    private int AntCount {
        get => _antCount;
        set {
            if (value == _antCount)
                return;
            if (value < 1 || value > enumerator.Current.Nodes.Count)
                return;

            _antCount = value;
        }
    }

    private Stopwatch stopwatch = new();
    private TimeSpan TimeSpan = new();

    protected override async Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            //await InitiateGraph(true);
            //await NextState(true);

            Task.Run(async () => {
                while (true) {
                    await Task.Delay(Delay);

                    if (autoAdvance)
                        await NextState(false);
                }
            });
        }
    }

    private async Task InitiateGraph(bool textbased) {
        graph = textbased ? GraphProblem.FromText(graphDefinition) :
        GraphProblem.RandomGraphProblem(MaxX, MaxY, NodeCount);
        CanvasWidth = (int)(Scale * (graph.FindMax().X + 1));
        CanvasHeight = (int)(Scale * (graph.FindMax().Y + 1));
        await NextState(true);
    }   

    private async Task NextState(bool reset) {
        if (reset) {
            stopwatch.Restart();
            await UpdateEnumerator();
        }
            
        if (enumerator == null)
            await InitiateGraph(true);

        if (!drawComplete) {
            if (enumerator.Current != null)
                previous = enumerator.Current.DeepCopy();

            enumerator.MoveNext();
            TimeSpan = stopwatch.Elapsed;
            
            if (previous != null && showPrevious && (algorithmEnum == AlgorithmEnum.SA || algorithmEnum == AlgorithmEnum.HC)) {
                previous.ComparePathEdges(enumerator.Current);
                await FillCanvas(previousCanvas);
            }

            if (enumerator.Current.Finished) {
                drawComplete = true;
                stopwatch.Stop();
            }

            await FillCanvas(currentCanvas);

            /* Simulated Annealing */
            if (enumerator.Current.Segments.Count > 0) {
                if (additionalCanvases != null && additionalCanvases.Length != 0) {
                    for (int i = 0; i < additionalCanvases.Length; i++) {
                        if (additionalCanvases[i] != null && algorithmEnum == AlgorithmEnum.SA && neighbourEnum == NeighbourType.TwoOpt) {
                            await FillCanvas(additionalCanvases[i]);
                        }
                    }
                }
            }

            StateHasChanged();
            @*UpdateVisualsFromGraphState();*@
    }
    }

    private async Task FillCanvas(Canvas canvas) {
        await using (var context = await canvas.GetContext2DAsync()) {
            await ResetCanvas(context);

            if (canvas == previousCanvas)
                await DrawPath(context, previous);

            if (canvas == currentCanvas)
                await DrawPath(context, enumerator.Current);
            
            for (int i = 0; i < enumerator.Current.Segments.Count; i++) {
                if (canvas == additionalCanvases[i] && !enumerator.Current.Finished) {
                    await CanvasRenderer.DrawEdges(context, enumerator.Current.Segments[i].Edges, CanvasHeight, false, false);
                    await CanvasRenderer.DrawNodes(context, enumerator.Current.Segments[i].Nodes, CanvasHeight);
                }
            }
        }
    }

    private async Task DrawPath(Context2D context, GraphState graph) {
        await CanvasRenderer.DrawEdges(context, graph.PathEdges, CanvasHeight);
        await CanvasRenderer.DrawNodes(context, graph.Nodes, CanvasHeight);
    }

    private async Task ResetAllCanvases() {
        if (previousCanvas != null && showPrevious && algorithmEnum == AlgorithmEnum.SA) {
            previous = null;
            await ResetCanvas(await previousCanvas.GetContext2DAsync());
        }

        if (currentCanvas != null) {
            await ResetCanvas(await currentCanvas.GetContext2DAsync());
        }
        
        if (enumerator != null && enumerator.Current != null && enumerator.Current.Segments.Count > 0) {
            for (int i = 0; i < additionalCanvases.Length; i++) {
                if (additionalCanvases[i] != null) {
                    if (algorithmEnum == AlgorithmEnum.SA && neighbourEnum == NeighbourType.TwoOpt) {
                        if (additionalCanvases[i].GetContext2DAsync() != null)
                            await ResetCanvas(await additionalCanvases[i].GetContext2DAsync());
                    }
                }
            }
        }
    }

    private async Task ResetCanvas(Context2D context) {
        await context.ClearRectAsync(0, 0, CanvasWidth, CanvasHeight);
        await CanvasRenderer.DrawGrid(context, graph.FindMax(), CanvasHeight);
    }

    private async Task UpdateEnumerator() {
        drawComplete = false;
        await ResetAllCanvases();

        switch (algorithmEnum) {
            case AlgorithmEnum.NN:
                nearestNeighbour.Start = graph.Nodes[StartNode];

                if (multiStart) {
                    enumerator = nearestNeighbour.MultiStart(graph).GetEnumerator();
                } else {
                    enumerator = nearestNeighbour.FindPath(graph).GetEnumerator();
                }                
                break;
            case AlgorithmEnum.SA:
                simulatedAnnealing.Alpha = AlphaSA;
                simulatedAnnealing.MaxIter1 = MaxIter1;
                simulatedAnnealing.MaxIter2 = MaxIter2;
                simulatedAnnealing.StartTemp = StartTemp;
                simulatedAnnealing.MinTemp = MinTemp;
                simulatedAnnealing.NeighbourEnum = neighbourEnum;
                enumerator = simulatedAnnealing.FindPath(graph).GetEnumerator();
                break;
            case AlgorithmEnum.ACS:
                antColonySystem.AntCount = AntCount;
                antColonySystem.Alpha = AlphaACS;
                antColonySystem.Rho = Rho;
                antColonySystem.Beta = Beta;
                antColonySystem.ExploitVsExplore = ExploitVsExplore;
                enumerator = antColonySystem.FindPath(graph).GetEnumerator();
                break;
            case AlgorithmEnum.HC:
                hillClimbing.NeighbourType = neighbourEnum;

                if (multiStart) {
                    enumerator = hillClimbing.MultiStart(graph).GetEnumerator();
                } else {
                    enumerator = hillClimbing.FindPath(graph).GetEnumerator();
                }
                
                break;
            default: break;
        }
    }

    @*private void UpdateVisualsFromGraphState() {
        if (algorithmEnum == AlgorithmEnum.NN)
            tableGenerator.UpdateFromGraphState(enumerator.Current);
        if (algorithmEnum == AlgorithmEnum.SA)
            chartGenerator.UpdateFromGraphState(enumerator.Current);
    }*@
}