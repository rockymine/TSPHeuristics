@page "/graph"
@using Excubo.Blazor.Canvas
@using Excubo.Blazor.Canvas.Contexts
@using System.Diagnostics
@using TravellingSalesmanProblem.Algorithms
@using TravellingSalesmanProblem.Graph
@using WebApplication.Utils
@using WebApplication.Components
@using StardustDL.RazorComponents.Markdown
<div class="container-fluid">
    <h2 class="font-weight-bold">Interactive visualization of different TSP heuristics</h2>
    <div class="row">
        <div class="col-md-3 p-0"><!-- Settings -->
            <div class="bg-custom-light custom-input-group">
                <AlgorithmSettings @bind-AlgorithmEnum="@AlgorithmEnum" @bind-MultiStart="@MultiStart"
                    @bind-ShowPrevious="@ShowPrevious" @bind-AnnotateEdges="@AnnotateEdges"
                    @bind-ColorizeChanges="@ColorizeChanges" @bind-AnimationDelay="@AnimationDelay"></AlgorithmSettings>
            </div>
        </div>
        <div class="col-md-9 p-0">
            <div class="bg-custom-light custom-input-group">
                <h5>Heuristic Settings</h5>
                @if (GraphHistory != null) {
                    @if (AlgorithmEnum == AlgorithmEnum.NN && !MultiStart) {
                        <NearestNeighborSettings @bind-StartNode="@StartNode"></NearestNeighborSettings>
                    }
                    @if (AlgorithmEnum == AlgorithmEnum.SA) {
                        <SimulatedAnnealingSettings @bind-AlphaSA="@AlphaSA" @bind-MaxIter1="@PhaseLength" 
                            @bind-MaxIter2="@MaxPhases" @bind-MinTemp="@MinTemp" @bind-StartTemp="@StartTemp"
                            @bind-NeighbourEnum="@NeighbourEnum"></SimulatedAnnealingSettings>
                    }
                    @if (AlgorithmEnum == AlgorithmEnum.HC) {
                        <NeighborFunctionSettings @bind-NeighbourEnum="@NeighbourEnum"></NeighborFunctionSettings>
                    }
                    @if (AlgorithmEnum == AlgorithmEnum.ACS) {
                        <AntColonySettings @bind-AlphaACS="AlphaACS" @bind-AntCount="@AntCount" @bind-Beta="@Beta"
                            @bind-Rho="@Rho" @bind-ExploitVsExplore="@StateTransition"></AntColonySettings>
                    }
                    <div class="form-group">
                        <button class="btn btn-danger" type="button" @onclick="e => UpdateEnumerator()">Reset</button>
                    </div>
                }
            </div>
        </div>
    </div>
    <div class="row">
        <p>
            <button class="btn btn-primary" @onclick="@(e => SettingsCollapse = SettingsCollapse == "" ? "collapse" : "")">
                Graph settings ˅
            </button>
        </p>
        <div class="@SettingsCollapse" id="collapseExample">
            <div class="row">
                <div class="col-md-6 p-0">
                    <div class="bg-custom-light custom-input-group">
                        <h5>Text-based graph</h5>
                        <div class="form-group">
                            <textarea class="form-control" @bind="DefaultGraph" style="height: 200px;"></textarea>
                        </div>
                        <div class="form-group">
                            <button class="btn btn-primary" type="button" @onclick="e => InitiateGraph(true)">Draw From Text</button>
                        </div>
                    </div>
                </div>
                <div class="col-md-6 p-0">
                    <div class="bg-custom-light custom-input-group">
                        <RandomGraphSettings @bind-NodeCount="NodeCount" @bind-MaxX="MaxX" @bind-MaxY="MaxY"></RandomGraphSettings>
                        <div class="form-group">
                            <button class="btn btn-primary" type="button" @onclick="e => InitiateGraph(false)">Draw Random Graph</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-md-8 p-0">
            <div class="bg-custom-light custom-input-group">
                <h5>Graph View</h5>
                <div class="row">
                    <div class="col">
                        <h5 class="font-weight-bold">Current</h5>
                        <Canvas @ref="@CurrentCanvas" width="@MainCanvasSettings.Width" height="@MainCanvasSettings.Height"></Canvas>
                    </div>
                    <div class="col">
                        @if (ShowPrevious && (AlgorithmEnum is AlgorithmEnum.SA or AlgorithmEnum.HC)) {
                            <h5 class="font-weight-bold">Previous</h5>
                            <Canvas @ref="@PreviousCanvas" width="@MainCanvasSettings.Width" height="@MainCanvasSettings.Height"></Canvas>
                        }
                    </div>
                </div>
            </div>
        </div>
        <div class="col-md-4 p-0">
            <div class="bg-custom-light custom-input-group">
                <h5>State</h5>
                @if (GraphHistory != null) {
                    <div class="row g-3">
                        <div class="input-group">
                            <div class="col-auto">
                                @if (!AutoAdvance) {
                                    <div class="form-group">
                                        <button type="button" disabled="@(GraphHistory.First == CurrentHistoryNode)" class="btn btn-primary btn-sm" data-bs-toggle="tooltip" data-bs-placement="top" title="Jump First" @onclick="e => JumpFirst()">«</button>
                                        <button type="button" disabled="@(GraphHistory.First == CurrentHistoryNode)" class="btn btn-primary btn-sm" data-bs-toggle="tooltip" data-bs-placement="top" title="Reverse" @onclick="e => ReverseHistory()">‹</button>
                                        <button type="button" disabled="@(GraphHistory.Last == CurrentHistoryNode)" class="btn btn-primary btn-sm" data-bs-toggle="tooltip" data-bs-placement="top" title="Advance" @onclick="e => AdvanceHistory()">›</button>
                                        <button type="button" disabled="@(GraphHistory.Last == CurrentHistoryNode)" class="btn btn-primary btn-sm" data-bs-toggle="tooltip" data-bs-placement="top" title="Jump Last" @onclick="e => JumpLast()">»</button>
                                    </div>
                                }
                            </div>
                        </div>
                    </div>
                    <div class="row">
                        <div class="input-group">
                            <div class="form-check">
                                <input class="form-check-input" type="checkbox" id="switchAdvance" @bind="@AutoAdvance">
                                <label class="form-check-label" for="switchAdvance">Auto Advance</label>
                            </div>
                        </div>
                    </div>
                }
                @if (CurrentHistoryNode != null) {
                    <span><b>Elapsed Time</b>: @TimeSpan.Minutes m @TimeSpan.Seconds s @TimeSpan.Milliseconds ms</span><br/>

                    @foreach (var kvp in CurrentHistoryNode.Value.Messages) {
                        <span><b>@kvp.Key</b>: @kvp.Value</span><br/>
                    }
                }
            </div>
        </div>
    </div>
    <div class="row">
        <div class="col-md-12">
            <h5>Details</h5>
            @if (GraphHistory != null && CurrentHistoryNode.Value != null && CurrentHistoryNode.Value.Equations.Count != 0) {
                <div class="row">
                <div class="col-md-6 col-sm-6">
                    <h3 class="font-weight-bold">Formulas</h3>
                        @foreach (var kvp in CurrentHistoryNode.Value.Equations) {
                            <p><b>@kvp.Key</b></p>
                            <MarkdownRenderer Value="@kvp.Value.Latex"/>
                            <MarkdownRenderer Value="@kvp.Value.Generate()"/>
                            <MarkdownRenderer Value="@kvp.Value.Result"/>
                        }
                    </div>
                </div> 
            }
            @*@if (AlgorithmEnum == AlgorithmEnum.SA && StateEnumerator != null && StateEnumerator.Current != null
            && StateEnumerator.Current.Segments != null && StateEnumerator.Current.Segments.Count != 0 && !DrawComplete) {
                <div class="row">
                    @if (CanvasArray != null && CanvasArray.Length != 0) {
                        <div class="col md-2">
                            <h5 class="font-weight-bold">Details</h5>
                            <div class="row">
                                @for (int i = 0; i < StateEnumerator.Current.Segments.Count; i++) {
                                    int j = i;
                                    <div class="col">
                                        <div class="card">
                                            <Canvas @ref="@CanvasArray[j]" width="@AdditionalCanvasSettings.Width"
                                                height="@AdditionalCanvasSettings.Height"></Canvas>
                                            <div class="card-body">
                                                <h5>@StateEnumerator.Current.Segments[j].Identifier</h5>
                                                <h6 class="card-subtitle mb-2 text-muted">@StateEnumerator.Current.Segments[j].Type</h6>
                                                @foreach (var info in StateEnumerator.Current.Segments[j].Info) {
                                                    <span><b>@info.Key</b>: @info.Value</span><br/>
                                                }
                                            </div>
                                        </div>
                                    </div>
                                }
                            </div>
                        </div>
                    }
                </div>
            }*@
        </div>
    </div>
    <TableGenerator @ref="@TableGenerator"></TableGenerator>
</div>

@code {
    private LinkedList<GraphState> GraphHistory;
    private LinkedListNode<GraphState> CurrentHistoryNode;
    
    private Canvas CurrentCanvas;
    private Canvas PreviousCanvas;
    private Canvas[] CanvasArray = new Canvas[5];

    private TableGenerator TableGenerator;

	private GraphProblem Instance;
    private GraphState PreviousState;
    private IEnumerator<GraphState> StateEnumerator;

    private AlgorithmEnum AlgorithmEnum;
    private NeighbourType NeighbourEnum;
    private NearestNeighbour NearestNeighbor = new();
    private SimulatedAnnealing SimulatedAnnealing = new();
    private AntAlgorithm AntAlgorithm = new();
    private HillClimbing HillClimbing = new();
	
	private string DefaultGraph = @"n,1,11,5
n,2,6,4
n,3,4,10
n,4,4,2
n,5,2,4
n,6,7,7
n,7,8,8
n,8,9,2
n,9,5,7
n,10,7,1
n,11,1,6
n,12,11,11";
    
    private bool AutoAdvance;
    private bool AnnotateEdges;
    private bool ColorizeChanges = true;
    private bool DrawComplete;
    private bool ShowPrevious = true;
    private bool MultiStart;
    private string SettingsCollapse = "";
    private CanvasSettings MainCanvasSettings = new();
    private CanvasSettings AdditionalCanvasSettings = new();

    private Stopwatch Stopwatch = new();
    private TimeSpan TimeSpan = new();

    private int _animationDelay = 1;
    private int AnimationDelay {
        get => _animationDelay;
        set {
            if (value == _animationDelay)
                return;
            if (value < 1 || value > 5000)
                return;

            _animationDelay = value;
        }
    }

    private int _maxX = 30;
    private int MaxX {
        get => _maxX;
        set {
            if (value == _maxX)
                return;
            if (value < 10 || value > 90)
                return;

            _maxX = value;
        }
    }

    private int _maxY = 30;
    private int MaxY {
        get => _maxY;
        set {
            if (value == _maxY)
                return;
            if (value < 10 || value > 90)
                return;

            _maxY = value;
        }
    }
    
    private int _nodeCount = 30;
    private int NodeCount {
        get => _nodeCount;
        set {
            if (value == _nodeCount)
                return;
            if (value < 5 || value > 90)
                return;

            _nodeCount = value;
        }
    }

    /* Nearest Neighbor */
    private int _startNode;
    private int StartNode {
        get => _startNode;
        set {
            if (value == _startNode)
                return;
            if (value < 0 || value > Instance.Nodes.Count - 1)
                return;

            _startNode = value;
        }
    }

    /* Simulated Annealing */
    private int _phaseLength = 1;
    private int PhaseLength {
        get => _phaseLength;
        set {
            if (value == _phaseLength)
                return;
            if (value < 1 || value > 20)
                return;

            _phaseLength = value;
        }
    }

    private int _maxPhases = 100;
    private int MaxPhases {
        get => _maxPhases;
        set {
            if (value == _maxPhases)
                return;
            if (value < 100 || value > 1000)
                return;

            _maxPhases = value;
        }
    }

    private double _startTemp = 100;
    private double StartTemp {
        get => _startTemp;
        set {
            if (value == _startTemp)
                return;
            if (value < 50 || value > 100_000) {
                return;
            }

            _startTemp = value;
        }
    }

    private double _minTemp = Math.Pow(10,-8);
    private double MinTemp {
        get => _minTemp;
        set {
            if (value == _minTemp)
                return;
            if (value < 0.0000001 || value >= _startTemp)
                return;

            _minTemp = value;
        }
    }

    private double _alphaSA = 0.98;
    private double AlphaSA {
        get => _alphaSA;
        set {
            if (value == _alphaSA)
                return;
            if (value < 0.5 || value >= 1)
                return;

            _alphaSA = value;
        }
    }

    /* Ant Algorithm */
    private double _alphaACS = 0.1;
    private double AlphaACS {
        get => _alphaACS;
        set {
            if (value == _alphaACS)
                return;
            if (value <= 0 || value >= 1)
                return;

            _alphaACS = value;
        }
    }

    private double _beta = 2;
    private double Beta {
        get => _beta;
        set {
            if (value == _beta)
                return;
            if (value <= 0 || value >= 10)
                return;

            _beta = value;
        }
    }

    private double _rho = 0.1;
    private double Rho {
        get => _rho;
        set {
            if (value == _rho)
                return;
            if (value <= 0 || value >= 1)
                return;

            _rho = value;
        }
    }

    private double _stateTransition = 0.9;
    private double StateTransition {
        get => _stateTransition;
        set {
            if (value == _stateTransition)
                return;
            if (value < 0.5 || value >= 1)
                return;

            _stateTransition = value;
        }
    }

    private int _antCount = 10;
    private int AntCount {
        get => _antCount;
        set {
            if (value == _antCount)
                return;
            if (value < 1 || value > StateEnumerator.Current.Nodes.Count)
                return;

            _antCount = value;
        }
    }

    protected override Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            Task.Run(async () => {
                while (true) {
                    await Task.Delay(AnimationDelay);

                    if (AutoAdvance)
                        await AdvanceHistory();
                }
            });
        }

        return base.OnAfterRenderAsync(firstRender);
    }

    private async Task InitiateGraph(bool textbased) {
        Instance = textbased ? GraphProblem.FromText(DefaultGraph)
            : GraphProblem.RandomGraphProblem(MaxX, MaxY, NodeCount);

        MainCanvasSettings.Max = Instance.FindMax();
        MainCanvasSettings.Scale = 30;
        MainCanvasSettings.NodeRadius = 8;

        AdditionalCanvasSettings.Max = Instance.FindMax();
        AdditionalCanvasSettings.Scale = 15;
        AdditionalCanvasSettings.NodeRadius = 6;

        //await NextState(true);
        await UpdateEnumerator();
    }

    private async Task JumpFirst() {
        var canChange = await CanChangeHistory();
        if (!canChange)
            return;

        if (GraphHistory.First == null)
            return;

        CurrentHistoryNode = GraphHistory.First;
        await Redraw();
    }

    private async Task JumpLast() {
        var canChange = await CanChangeHistory();
        if (!canChange)
            return;

        if (GraphHistory.Last == null)
            return;

        CurrentHistoryNode = GraphHistory.Last;
        await Redraw();
    }

    private async Task AdvanceHistory() {
        var canChange = await CanChangeHistory();
        if (!canChange)
            return;

        if (CurrentHistoryNode.Next == null)
            return;

        CurrentHistoryNode = CurrentHistoryNode.Next;
        await Redraw();
    }

    private async Task ReverseHistory() {
        var canChange = await CanChangeHistory();
        if (!canChange)
            return;

        if (CurrentHistoryNode.Previous == null)
            return;

        CurrentHistoryNode = CurrentHistoryNode.Previous;
        await Redraw();
    }

    private async Task<bool> CanChangeHistory() {
        if (GraphHistory == null)
            return false;
        if (CurrentHistoryNode == null) {
            CurrentHistoryNode = GraphHistory.First;
            await Redraw();
            return false;
        }

        return true;
    }

    private async Task Redraw() {
        await FillCanvases();
        UpdateVisualsFromGraphState();
        StateHasChanged();
    }

    private async Task FillCanvases() {
        if (CurrentHistoryNode.Previous != null && ShowPrevious && (AlgorithmEnum is AlgorithmEnum.SA or AlgorithmEnum.HC)) {
            await ResetCanvas(await PreviousCanvas.GetContext2DAsync(), MainCanvasSettings);
            await FillCanvas(PreviousCanvas, CurrentHistoryNode.Previous.Value);
        }

        await ResetCanvas(await CurrentCanvas.GetContext2DAsync(), MainCanvasSettings);
        await FillCanvas(CurrentCanvas, CurrentHistoryNode.Value);
        
        @*for (int i = 0; i < CanvasArray.Length; i++) {
            if (CanvasArray[i] != null && !DrawComplete && CurrentHistoryNode.Value.Segments.Count > 0) {
                await ResetCanvas(await CanvasArray[i].GetContext2DAsync(), AdditionalCanvasSettings);
                await FillCanvas(CanvasArray[i]);
            }
        }*@
    }

    private async Task FillCanvas(Canvas canvas, GraphState state) {
        await using (var context = await canvas.GetContext2DAsync()) {
            @*if (canvas == PreviousCanvas) {
                PreviousState.ComparePathEdges(StateEnumerator.Current);

                await CanvasRenderer.DrawPath(context, PreviousState.Nodes, PreviousState.PathEdges,
                    MainCanvasSettings, AnnotateEdges, ColorizeChanges);
            }                

            if (canvas == CurrentCanvas) {
                await CanvasRenderer.DrawPath(context, StateEnumerator.Current.Nodes, StateEnumerator.Current.PathEdges,
                    MainCanvasSettings, AnnotateEdges, ColorizeChanges);
            }*@                
            
            await CanvasRenderer.DrawPath(context, state.Nodes, state.PathEdges,
                    MainCanvasSettings, AnnotateEdges, ColorizeChanges);

            @*for (int i = 0; i < StateEnumerator.Current.Segments.Count; i++) {
                if (canvas == CanvasArray[i] && !StateEnumerator.Current.Finished) {
                    var nodes = StateEnumerator.Current.Segments[i].Nodes;
                    var edges = StateEnumerator.Current.Segments[i].Edges;

                    await CanvasRenderer.DrawPath(context, nodes, edges, AdditionalCanvasSettings, false, false);
                }
            }*@
    }
    }

    private async Task ResetCanvases() {
        if (PreviousCanvas != null && ShowPrevious && (AlgorithmEnum is AlgorithmEnum.SA or AlgorithmEnum.HC)) {
            PreviousState = null;
            await ResetCanvas(await PreviousCanvas.GetContext2DAsync(), MainCanvasSettings);
        }

        if (CurrentCanvas != null) {
            await ResetCanvas(await CurrentCanvas.GetContext2DAsync(), MainCanvasSettings);
        }
        
        if (StateEnumerator != null && StateEnumerator.Current != null && StateEnumerator.Current.Segments.Count > 0) {
            for (int i = 0; i < CanvasArray.Length; i++) {
                if (CanvasArray[i] != null) {
                    if (AlgorithmEnum == AlgorithmEnum.SA && NeighbourEnum == NeighbourType.TwoOpt) {
                        if (CanvasArray[i].GetContext2DAsync() != null)
                            await ResetCanvas(await CanvasArray[i].GetContext2DAsync(), AdditionalCanvasSettings);
                    }
                }
            }
        }
    }

    private async Task ResetCanvas(Context2D context, CanvasSettings settings) {
        await context.ClearRectAsync(0, 0, settings.Width, settings.Height);
        await CanvasRenderer.DrawGrid(context, settings);
    }

    private async Task UpdateEnumerator() {
        Instance.Reset();
        DrawComplete = false;
        Stopwatch.Restart();
        TableGenerator.Reset();

        await ResetCanvases();
        //surround with Stopwatch 
        switch (AlgorithmEnum) {
            case AlgorithmEnum.NN:
                NearestNeighbor.Start = Instance.Nodes[StartNode];
                GraphHistory = NearestNeighbor.FindPath(Instance);
                break;
            case AlgorithmEnum.SA:
                SimulatedAnnealing.Alpha = AlphaSA;
                SimulatedAnnealing.PhaseLength = PhaseLength;
                SimulatedAnnealing.MaxPhases = MaxPhases;
                SimulatedAnnealing.StartTemp = StartTemp;
                SimulatedAnnealing.MinTemp = MinTemp;
                SimulatedAnnealing.NeighbourEnum = NeighbourEnum;
                GraphHistory = SimulatedAnnealing.FindPath(Instance);
                break;
            case AlgorithmEnum.ACS:
                AntAlgorithm.AntCount = AntCount;
                AntAlgorithm.Alpha = AlphaACS;
                AntAlgorithm.Rho = Rho;
                AntAlgorithm.Beta = Beta;
                AntAlgorithm.StateTransition = StateTransition;
                //StateEnumerator = AntAlgorithm.FindPath(Instance).GetEnumerator();

                GraphHistory = AntAlgorithm.FindPath(Instance);
                break;
            case AlgorithmEnum.HC:
                HillClimbing.NeighbourType = NeighbourEnum;
                StateEnumerator = MultiStart ? HillClimbing.MultiStart(Instance).GetEnumerator() :
                    HillClimbing.FindPath(Instance).GetEnumerator();
                break;
            default: break;
        }

        CurrentHistoryNode = GraphHistory.First;
        await Redraw();
    }

    private void UpdateVisualsFromGraphState() {
        if (AlgorithmEnum == AlgorithmEnum.NN) {
            TableGenerator.UpdateFromGraphState(CurrentHistoryNode.Value, TableType.DistanceMatrix);
        } else if ((AlgorithmEnum is AlgorithmEnum.SA or AlgorithmEnum.HC) && NeighbourEnum is NeighbourType.TwoOpt) {
            TableGenerator.UpdateFromGraphState(CurrentHistoryNode.Value, TableType.SwapSummary);
        } else {
            TableGenerator.UpdateFromGraphState(CurrentHistoryNode.Value, TableType.RouteSummary);
        }
    }
}