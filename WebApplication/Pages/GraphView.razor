@page "/graph"
@using Excubo.Blazor.Canvas
@using Excubo.Blazor.Canvas.Contexts
@using System.Diagnostics
@using TravellingSalesmanProblem.Algorithms
@using TravellingSalesmanProblem.Graph
@using WebApplication.Utils
@using WebApplication.Components
@using StardustDL.RazorComponents.Markdown
<div class="container-fluid">
    <h2 class="font-weight-bold">Interactive visualization of different TSP heuristics</h2>
    <div class="row">
        <!-- Algorithm Settings -->
        <div class="col-md-3 p-0">
            <div class="bg-custom-light custom-input-group">
                <AlgorithmSettings @bind-AlgorithmEnum="@AlgorithmEnum" @bind-MultiStart="@MultiStart"/>
                <CanvasDisplaySettings @bind-Scale="@Scale" @bind-NodeRadius="@NodeRadius"
                    @bind-ShowGrid="@ShowGrid" @bind-AnnotateEdges="@AnnotateEdges" @bind-ColorizeChanges="@ColorizeChanges"
                    @bind-AnimationDelay="@AnimationDelay"/>
                <span><b>Execution Time</b>: @TimeSpan.Minutes m @TimeSpan.Seconds s @TimeSpan.Milliseconds ms</span><br/>
            </div>
        </div>
        <!-- Heuristic Settings -->
        <div class="col-md-9 p-0">
            <div class="bg-custom-light custom-input-group">
                <h5>Heuristic Settings</h5>
                @if (GraphHistory != null) {
                    @if (AlgorithmEnum == AlgorithmEnum.NN && !MultiStart) {
                        <NearestNeighborSettings @bind-StartNode="@StartNode"/>
                    }
                    @if (AlgorithmEnum == AlgorithmEnum.SA) {
                        <SimulatedAnnealingSettings @bind-AlphaSA="@AlphaSA" @bind-MaxIter1="@PhaseLength" 
                            @bind-MaxIter2="@MaxPhases" @bind-MinTemp="@MinTemp" @bind-StartTemp="@StartTemp"
                            @bind-NeighbourEnum="@NeighbourEnum"/>
                    }
                    @if (AlgorithmEnum == AlgorithmEnum.HC) {
                        <HillClimbingSettings @bind-NeighbourEnum="@NeighbourEnum" @bind-DescentType="DescentType"/>
                    }
                    @if (AlgorithmEnum == AlgorithmEnum.ACS) {
                        <AntColonySettings @bind-AlphaACS="AlphaACS" @bind-AntCount="@AntCount" @bind-Beta="@Beta"
                            @bind-Rho="@Rho" @bind-ExploitVsExplore="@StateTransition"/>
                    }
                    <div class="form-group">
                        <button class="btn btn-danger" type="button" @onclick="e => UpdateEnumerator()">Reset</button>
                    </div>
                }
            </div>
        </div>
    </div>
    <!-- Graph Settings -->
    <div class="row">
        <p>
            <button class="btn btn-primary" @onclick="@(e => SettingsCollapse = SettingsCollapse == "" ? "collapse" : "")">
                Graph settings ˅
            </button>
        </p>
        <div class="@SettingsCollapse" id="collapseExample">
            <div class="row">
                <!-- Text -->
                <div class="col-md-6 p-0">
                    <div class="bg-custom-light custom-input-group">
                        <h5>Text-based graph</h5>
                        <div class="form-group">
                            <textarea class="form-control" @bind="DefaultGraph" style="height: 200px;"></textarea>
                        </div>
                        <div class="form-group">
                            <button class="btn btn-primary" type="button" @onclick="e => InitiateGraph(true)">Draw From Text</button>
                        </div>
                    </div>
                </div>
                <!-- Random -->
                <div class="col-md-6 p-0">
                    <div class="bg-custom-light custom-input-group">
                        <RandomGraphSettings @bind-NodeCount="NodeCount" @bind-MaxX="MaxX" @bind-MaxY="MaxY"/>
                        <div class="form-group">
                            <button class="btn btn-primary" type="button" @onclick="e => InitiateGraph(false)">Draw Random Graph</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="row">
        <!-- Graphs -->
        <div class="col-md-8 p-0">
            <div class="bg-custom-light custom-input-group">
                <h5>Graph View</h5>
                <div class="row">
                    <div class="col">
                        <h5 class="font-weight-bold">Previous (Iteration Start)</h5>
                        @if (AlgorithmEnum is AlgorithmEnum.SA or AlgorithmEnum.HC) {
                            <Canvas @ref="@PreviousCanvas" width="@MainCanvasSettings.Width" height="@MainCanvasSettings.Height"/>
                        }
                    </div>
                    <div class="col">
                        <h5 class="font-weight-bold">Current (Iteration End)</h5>
                        <Canvas @ref="@CurrentCanvas" width="@MainCanvasSettings.Width" height="@MainCanvasSettings.Height"/>
                    </div>
                </div>
            </div>
        </div>
        <!-- State -->
        <div class="col-md-4 p-0">
            <div class="bg-custom-light custom-input-group">
                <h5>State</h5>
                @if (GraphHistory != null) {
                    <div class="row g-3">
                        <div class="input-group">
                            <div class="col-auto">
                                    <div class="form-group">
                                        <button type="button" disabled="@(GraphHistory.First == CurrentHistoryNode)" class="btn btn-primary btn-sm" data-bs-toggle="tooltip" data-bs-placement="top" title="Jump First" @onclick="e => JumpFirst()">«</button>
                                        <button type="button" disabled="@(GraphHistory.First == CurrentHistoryNode)" class="btn btn-primary btn-sm" data-bs-toggle="tooltip" data-bs-placement="top" title="Reverse" @onclick="e => ReverseHistory()">‹</button>
                                        @if (AutoAdvance) {
                                            <button type="button" class="btn btn-primary btn-sm" data-bs-toggle="tooltip" data-bs-placement="top" title="AutoAdvance = false" @onclick="e => AutoAdvance = false">⏸</button>
                                        } else {
                                            <button type="button" class="btn btn-primary btn-sm" data-bs-toggle="tooltip" data-bs-placement="top" title="AutoAdvance = true" @onclick="e => AutoAdvance = true">▶</button>
                                        }
                                        <button type="button" disabled="@(GraphHistory.Last == CurrentHistoryNode)" class="btn btn-primary btn-sm" data-bs-toggle="tooltip" data-bs-placement="top" title="Advance" @onclick="e => AdvanceHistory()">›</button>
                                        <button type="button" disabled="@(GraphHistory.Last == CurrentHistoryNode)" class="btn btn-primary btn-sm" data-bs-toggle="tooltip" data-bs-placement="top" title="Jump Last" @onclick="e => JumpLast()">»</button>
                                    </div>
                            </div>
                        </div>
                    </div>
                    <div class="row">
                        @if (AlgorithmEnum is AlgorithmEnum.SA) {
                            if (CurrentHistoryNode.Value.ChartInfo.Count >= 1) {
                                <ChartJS @ref="@ChartJS[0]" Chart="@CurrentHistoryNode.Value.ChartInfo[0]" ChartID="sa_temperature"></ChartJS>
                            }
                            if (CurrentHistoryNode.Value.ChartInfo.Count >= 2) {
                                <ChartJS @ref="@ChartJS[1]" Chart="@CurrentHistoryNode.Value.ChartInfo[1]" ChartID="sa_distance"></ChartJS>
                            }
                        }
                    </div>
                }
                @if (CurrentHistoryNode != null) {
                    @foreach (var kvp in CurrentHistoryNode.Value.Messages) {
                        <span><b>@kvp.Key</b>: @kvp.Value</span><br/>
                    }
                }
            </div>
        </div>
    </div>
    <div class="row">
        <!-- Details -->
        <div class="col-md-12 p-0">
            <div class="bg-custom-light custom-input-group">
                <h5>Details</h5>
                @if (GraphHistory != null && CurrentHistoryNode.Value != null && CurrentHistoryNode.Value.Equations.Count != 0) {
                    <div class="row">
                    <div class="col-md-6 col-sm-6">
                        <h3 class="font-weight-bold">Formulas</h3>
                            @foreach (var kvp in CurrentHistoryNode.Value.Equations) {
                                <p><b>@kvp.Key</b></p>
                                <MarkdownRenderer Value="@kvp.Value.Latex"/>
                                <MarkdownRenderer Value="@kvp.Value.Generate()"/>
                                <MarkdownRenderer Value="@kvp.Value.Result"/>
                            }
                        </div>
                    </div>
                }
            </div>
        </div>
    </div>
    <div class="row">
        <!-- Tables -->
        <div class="col-md-12 p-0">
            <div class="bg-custom-light custom-input-group">
                <h5>Table</h5>
                <TableGenerator @ref="@TableGenerator"/>
            </div>
        </div>
    </div>
</div>

@code {
    private LinkedList<GraphState> GraphHistory;
    private LinkedListNode<GraphState> CurrentHistoryNode;
    
    private Canvas PreviousCanvas;
    private Canvas CurrentCanvas;
    @*private Canvas[] CanvasArray = new Canvas[5];*@

    private TableGenerator TableGenerator;
    private ChartJS[] ChartJS = new ChartJS[5];

	private GraphProblem Instance;

    private AlgorithmEnum AlgorithmEnum;
    private NeighbourType NeighbourEnum;
    private DescentType DescentType;
    private NearestNeighbour NearestNeighbor = new();
    private SimulatedAnnealing SimulatedAnnealing = new();
    private AntAlgorithm AntAlgorithm = new();
    private AntSystem AntSystem = new();
    private HillClimbing HillClimbing = new();
	
	private string DefaultGraph = @"n,1,11,5
n,2,6,4
n,3,4,10
n,4,4,2
n,5,2,4
n,6,7,7
n,7,8,8
n,8,9,2
n,9,5,7
n,10,7,1
n,11,1,6
n,12,11,11";
    
    private bool AutoAdvance;
    private bool AnnotateEdges;
    private bool ColorizeChanges = true;
    private string BackgroundColor = "#FFFFFF";
    private bool MultiStart;
    private bool ShowGrid = true;
    private string SettingsCollapse = "";
    private CanvasSettings MainCanvasSettings = new();
    private CanvasSettings AdditionalCanvasSettings = new();

    private Stopwatch Stopwatch = new();
    private TimeSpan TimeSpan = new();

    private float _scale = 30;
    private float Scale {
        get => _scale;
        set {
            if (value == _scale)
                return;
            if (value < 10 || value > 40)
                return;

            _scale = value;
        }
    }

    private float _nodeRadius = 8;
    private float NodeRadius {
        get => _nodeRadius;
        set {
            if (value == _nodeRadius)
                return;
            if (value < 1 || value > 10)
                return;

            _nodeRadius = value;
        }
    }

    private int _animationDelay = 1;
    private int AnimationDelay {
        get => _animationDelay;
        set {
            if (value == _animationDelay)
                return;
            if (value < 1 || value > 5000)
                return;

            _animationDelay = value;
        }
    }

    private int _maxX = 30;
    private int MaxX {
        get => _maxX;
        set {
            if (value == _maxX)
                return;
            if (value < 10 || value > 90)
                return;

            _maxX = value;
        }
    }

    private int _maxY = 30;
    private int MaxY {
        get => _maxY;
        set {
            if (value == _maxY)
                return;
            if (value < 10 || value > 90)
                return;

            _maxY = value;
        }
    }
    
    private int _nodeCount = 30;
    private int NodeCount {
        get => _nodeCount;
        set {
            if (value == _nodeCount)
                return;
            if (value < 5 || value > 90)
                return;

            _nodeCount = value;
        }
    }

    /* Nearest Neighbor */
    private int _startNode;
    private int StartNode {
        get => _startNode;
        set {
            if (value == _startNode)
                return;
            if (value < 0 || value > Instance.Nodes.Count - 1)
                return;

            _startNode = value;
        }
    }

    /* Simulated Annealing */
    private int _phaseLength = 1;
    private int PhaseLength {
        get => _phaseLength;
        set {
            if (value == _phaseLength)
                return;
            if (value < 1 || value > 20)
                return;

            _phaseLength = value;
        }
    }

    private int _maxPhases = 100;
    private int MaxPhases {
        get => _maxPhases;
        set {
            if (value == _maxPhases)
                return;
            if (value < 100 || value > 1000)
                return;

            _maxPhases = value;
        }
    }

    private double _startTemp = 100;
    private double StartTemp {
        get => _startTemp;
        set {
            if (value == _startTemp)
                return;
            if (value < 50 || value > 100_000) {
                return;
            }

            _startTemp = value;
        }
    }

    private double _minTemp = Math.Pow(10,-8);
    private double MinTemp {
        get => _minTemp;
        set {
            if (value == _minTemp)
                return;
            if (value < 0.0000001 || value >= _startTemp)
                return;

            _minTemp = value;
        }
    }

    private double _alphaSA = 0.98;
    private double AlphaSA {
        get => _alphaSA;
        set {
            if (value == _alphaSA)
                return;
            if (value < 0.5 || value >= 1)
                return;

            _alphaSA = value;
        }
    }

    /* Ant Algorithm */
    private double _alphaACS = 0.1;
    private double AlphaACS {
        get => _alphaACS;
        set {
            if (value == _alphaACS)
                return;
            if (value <= 0 || value >= 1)
                return;

            _alphaACS = value;
        }
    }

    private double _beta = 2;
    private double Beta {
        get => _beta;
        set {
            if (value == _beta)
                return;
            if (value <= 0 || value >= 10)
                return;

            _beta = value;
        }
    }

    private double _rho = 0.1;
    private double Rho {
        get => _rho;
        set {
            if (value == _rho)
                return;
            if (value <= 0 || value >= 1)
                return;

            _rho = value;
        }
    }

    private double _stateTransition = 0.9;
    private double StateTransition {
        get => _stateTransition;
        set {
            if (value == _stateTransition)
                return;
            if (value < 0.5 || value >= 1)
                return;

            _stateTransition = value;
        }
    }

    private int _antCount = 10;
    private int AntCount {
        get => _antCount;
        set {
            if (value == _antCount)
                return;
            if (value < 1 || value > Instance.Nodes.Count)
                return;

            _antCount = value;
        }
    }

    protected override Task OnAfterRenderAsync(bool firstRender) {
        if (firstRender) {
            Task.Run(async () => {
                while (true) {
                    await Task.Delay(AnimationDelay);

                    if (AutoAdvance)
                        await AdvanceHistory();
                }
            });
        }

        return base.OnAfterRenderAsync(firstRender);
    }

    private async Task InitiateGraph(bool textbased) {
        Instance = textbased ? GraphProblem.FromText(DefaultGraph)
            : GraphProblem.RandomGraphProblem(MaxX, MaxY, NodeCount);

        MainCanvasSettings.Max = Instance.FindMax();
        MainCanvasSettings.Scale = Scale;
        MainCanvasSettings.NodeRadius = NodeRadius;
        MainCanvasSettings.ShowGrid = ShowGrid;
        MainCanvasSettings.BackgroundColor = BackgroundColor;

        await UpdateEnumerator();
    }

    private async Task JumpFirst() {
        var canChange = await CanChangeHistory();
        if (!canChange)
            return;

        if (GraphHistory.First == null)
            return;

        CurrentHistoryNode = GraphHistory.First;
        await Redraw();
    }

    private async Task JumpLast() {
        var canChange = await CanChangeHistory();
        if (!canChange)
            return;

        if (GraphHistory.Last == null)
            return;

        CurrentHistoryNode = GraphHistory.Last;
        await Redraw();
    }

    private async Task AdvanceHistory() {
        var canChange = await CanChangeHistory();
        if (!canChange)
            return;

        if (CurrentHistoryNode.Next == null)
            return;

        CurrentHistoryNode = CurrentHistoryNode.Next;
        await Redraw();
    }

    private async Task ReverseHistory() {
        var canChange = await CanChangeHistory();
        if (!canChange)
            return;

        if (CurrentHistoryNode.Previous == null)
            return;

        CurrentHistoryNode = CurrentHistoryNode.Previous;
        await Redraw();
    }

    private async Task<bool> CanChangeHistory() {
        if (GraphHistory == null)
            return false;
        if (CurrentHistoryNode == null) {
            CurrentHistoryNode = GraphHistory.First;
            await Redraw();
            return false;
        }

        return true;
    }

    private async Task Redraw() {
        MainCanvasSettings.Annotate = AnnotateEdges;
        MainCanvasSettings.Colorize = ColorizeChanges;

        await FillCanvases();
        await UpdateVisualsFromGraphState();
        StateHasChanged();
    }

    private async Task FillCanvases() {
        if (CurrentHistoryNode.Previous != null && (AlgorithmEnum is AlgorithmEnum.SA or AlgorithmEnum.HC)) {
            await ResetCanvas(await PreviousCanvas.GetContext2DAsync(), MainCanvasSettings);
            await FillCanvas(PreviousCanvas, CurrentHistoryNode.Previous.Value);
        }

        await ResetCanvas(await CurrentCanvas.GetContext2DAsync(), MainCanvasSettings);
        await FillCanvas(CurrentCanvas, CurrentHistoryNode.Value);
    }

    private async Task FillCanvas(Canvas canvas, GraphState state) {
        await using (var context = await canvas.GetContext2DAsync()) {
            await CanvasRenderer.DrawEdges(context, state, CurrentHistoryNode, MainCanvasSettings);
            await CanvasRenderer.DrawNodes(context, state, CurrentHistoryNode, MainCanvasSettings);
        }
    }

    private async Task ResetCanvases() {
        if (PreviousCanvas != null && (AlgorithmEnum is AlgorithmEnum.SA or AlgorithmEnum.HC)) {
            await ResetCanvas(await PreviousCanvas.GetContext2DAsync(), MainCanvasSettings);
        }

        if (CurrentCanvas != null) {
            await ResetCanvas(await CurrentCanvas.GetContext2DAsync(), MainCanvasSettings);
        }
    }

    private async Task ResetCanvas(Context2D context, CanvasSettings settings) {
        await context.ClearRectAsync(0, 0, settings.Width, settings.Height);
        await context.FillStyleAsync(settings.BackgroundColor);
        await context.FillRectAsync(0, 0, settings.Width, settings.Height);

        if (settings.ShowGrid)
            await CanvasRenderer.DrawGrid(context, settings);
    }

    private async Task UpdateEnumerator() {
        Instance.Reset();
        TableGenerator.Reset();
        await ResetCanvases();

        
        Stopwatch.Restart();

        switch (AlgorithmEnum) {
            case AlgorithmEnum.NN:
                NearestNeighbor.Start = Instance.Nodes[StartNode];
                GraphHistory = NearestNeighbor.FindPath(Instance);
                break;
            case AlgorithmEnum.SA:
                SimulatedAnnealing.Alpha = AlphaSA;
                SimulatedAnnealing.PhaseLength = PhaseLength;
                SimulatedAnnealing.MaxPhases = MaxPhases;
                SimulatedAnnealing.StartTemp = StartTemp;
                SimulatedAnnealing.MinTemp = MinTemp;
                SimulatedAnnealing.NeighbourEnum = NeighbourEnum;
                GraphHistory = SimulatedAnnealing.FindPath(Instance);
                break;
            case AlgorithmEnum.ACS:
                @*AntAlgorithm.AntCount = AntCount;
                AntAlgorithm.Alpha = AlphaACS;
                AntAlgorithm.Rho = Rho;
                AntAlgorithm.Beta = Beta;
                AntAlgorithm.StateTransition = StateTransition;
                GraphHistory = AntAlgorithm.FindPath(Instance);*@

                AntSystem.Alpha = AlphaACS;
                AntSystem.Beta = Beta;
                GraphHistory = AntSystem.FindPath(Instance);
                break;
            case AlgorithmEnum.HC:
                HillClimbing.NeighbourEnum = NeighbourEnum;
                HillClimbing.DescentType = DescentType;
                GraphHistory = HillClimbing.FindPath(Instance);
                break;
            default: break;
        }

        Stopwatch.Stop();
        TimeSpan = Stopwatch.Elapsed;

        CurrentHistoryNode = GraphHistory.First;
        await Redraw();
    }

    private async Task UpdateVisualsFromGraphState() {
        TableGenerator.UpdateFromGraphState(CurrentHistoryNode, AlgorithmEnum, NeighbourEnum);
        foreach (var chart in ChartJS) {
            if (chart != null)
                await chart.UpdateFromGraphState();
        }
    }
}